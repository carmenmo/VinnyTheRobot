#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in2,    ir_center,      sensorReflection)
#pragma config(Sensor, in3,    ir_right,       sensorReflection)
#pragma config(Sensor, in4,    ir_left,        sensorReflection)
#pragma config(Sensor, dgtl2,  rangefinder,    sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  cableAttachLED, sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  beaconFoundLED, sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, button,         sensorTouch)
#pragma config(Motor,  port1,           viewMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           steerMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          driveMotor,    tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define highSpeed     120  //all these constants are used for the drive motor in different states
#define lowSpeed        30
#define steerSpeed    30

#define steerLeft        30    //these motor speeds are used by the steer motor only
#define steerRight    -30

#define sharpRotateMSEC        550  //When the steer motor is activated for this amount of time
																			//the wheels will be turned fully

#define reverseSwitchMSEC    2500 //this is the amount of time the robot will steer forwards
																		//before switching into steering reverse

#define cableAttachDistance    5 //cm after the ir sensors indicate that the robot is directly
																	//in front of the beacon
                              //this distance will be detected by the rangefinder and signal the robot
																//to attach the cable

#define dangerDistance            20 //cm, for detecting walls

#define viewStraightMin        2550  //this is the lowest potentiometer reading for a straight-facing viewer
#define viewStraightMax        2650 //this is the highest potentiometer reading for a straight-facing viewer

#define viewLeftMin                3650 //lowest left-viewing potentiometer reading
#define viewLeftMax                3750    //highest left-viewing potentiometer reading

#define viewRightMin            1500 //lowest right-viewing potentiometer reading
#define viewRightMax            1600 //highest right-viewing potentiometer reading

#define viewMotorLeft        20				//the speed for the viewMotor when it turns to the left
#define viewMotorRight        -20			//the speed for the viewMotor when it turns to the right

bool button_pushed;

const int light_threshold = 250;
int ir_value_1;
int ir_value_2;

//this function returns true if the beacon is found. It searches for a difference
//in values detected by the light sensor passed by the parameter over a time of
//150msec, in order to detect the 20Hz beacon signal.
bool beaconMonitor(tSensors ir_sensor){

            ir_value_1 = sensorValue(ir_sensor);
            wait1Msec(150);
            ir_value_2 = sensorValue(ir_sensor);

            if(abs(ir_value_1 - ir_value_2) > 250)
                return true;
            else
                return false;

}

//this function returns the sensor value of the potentiometer
int readPotentiometer(){
    return SensorValue(potentiometer);
}

//this function keeps track of button pushes to commence operations
void buttonMonitor()
{
  if(SensorValue(button) && !button_pushed)
        button_pushed = true;

  if(SensorValue(button) && button_pushed)
      button_pushed = false;
}

//This function steers the robot left with the front wheels rotated all the way
void sharpLeft()
{
    motor[driveMotor] = steerSpeed;
    wait1Msec(100);
    motor[steerMotor] = steerLeft;
    wait1Msec(sharpRotateMSEC);
    motor[steerMotor] = 0;
}

//this function is used along with sharpLeft while the robot is rotating.
//it is called after a time of reverseSwitchMSEC elapses
void sharpLeftReverse()
{
    motor[driveMotor] = -steerSpeed;
    wait1Msec(100);
    motor[steerMotor] = -steerLeft;
    wait1Msec(2*sharpRotateMSEC);
}

//This function steers the robot right with the front wheels rotated all the way
void sharpRight()
{
    motor[driveMotor] = steerSpeed;
    wait1Msec(100);
    motor[steerMotor] = -steerLeft;
    wait1Msec(sharpRotateMSEC);
}

//this function is used along with sharpRight while the robot is rotating.
//it is called after a time of reverseSwitchMSEC elapses
void sharpRightReverse()
{
    motor[driveMotor] = -steerSpeed;
    wait1Msec(100);
    motor[steerMotor] = steerLeft;
    wait1Msec(2*sharpRotateMSEC);
}

//this function returns the sensor value of the ultrasonic rangefinder
int rangeChecker(){
    return SensorValue(rangefinder);
}

int rightRangeVal;
int leftRangeVal;
int frontRangeVal;

void seekWalls(){    //will search with viewer to find closest wall, then position viewer towards that wall
            frontRangeVal = rangeChecker();
            motor[viewMotor] = viewMotorLeft;
            while(readPotentiometer()<viewLeftMin){
            }
            motor[viewMotor] = 0;
            leftRangeVal = rangeChecker();
            wait1Msec(250);
            motor[viewMotor] = viewMotorRight;
            while(readPotentiometer()>viewRightMax){
            }
            motor[viewMotor] = 0;
            rightRangeVal = rangeChecker();
            wait1Msec(250);
            if(leftRangeVal<rightRangeVal){
                motor[viewMotor] = viewMotorLeft;
                while(readPotentiometer()<viewLeftMin){
                    potentiometerValue = readPotentiometer();
                }
            }else if(frontRangeVal < rightRangeVal){
                motor[viewMotor] = viewMotorLeft;
                while(readPotentiometer()<viewStraightMin){
                }
            }
            motor[viewMotor] = 0;
}

bool centerDetect;  			//true when ir_center (the ir sensor attached to the viewer) detects the beacon
bool leftDetect;          //true when ir_left detects the beacon
bool rightDetect;					//true when ir_right detects the beacon
bool facingStraight;			//true when the potentiometer indicates that the viewer is facing straight
															//used to verify robot position with respect to beacon
bool cableDistanceGood;		//true when the ultrasonic rangefinder indicates that the robot is in cable attaching distance from the beacon


//the main task contains three while loops corresponding to three different tests and code files.

//the first one detects the beacon
//the second one makes the robot face the beacon
//the third one checks for cable attaching



task main()
{

	//if the robot does not detect the beacon directly in front of it, it will
//move the viewer left to right, pausing for 500msec at each side to allow for readings.
	    while(true){
        buttonMonitor();
        if(button_pushed){
            clearTimer(T1);
            while(time1(T1) < 500){
                if(beaconMonitor(ir_center)){
                    SensorValue[beaconFoundLED] = 1;
                    centerDetect = true;
                    break;
                }
            }
            if(centerDetect)
                break;
            motor[viewMotor] = viewMotorLeft;
            while(readPotentiometer()<viewLeftMin){
            }
            motor[viewMotor] = 0;
            while(time1(T1) < 500){
                if(beaconMonitor(ir_center)){
                    SensorValue[beaconFoundLED] = 1;
                    centerDetect = true;
                    break;
                }
            }
            if(centerDetect)
                break;
            wait1Msec(250);
            motor[viewMotor] = viewMotorRight;
            while(readPotentiometer()>viewRightMax){
            }
            motor[viewMotor] = 0;
            if(beaconMonitor(ir_center)){
                SensorValue[beaconFoundLED] = 1;
                centerDetect = true;
            }//if beacon
        }//if button
    }//while true

    //if the beacon is not detected with the viewer, the robot will rotate by performing a series
    //of forwards and backwards turns with the ir_sensors taking in data.

    //if the beacon is found, viewer will return to facing straight and the robot will execute the same turns
    //in the direction indicated by the viewer.

    //make robot face beacon

    while(true){

        if(readPotentiometer()>viewStraightMax){ //if robot viewer is facing left
            motor[viewMotor] = viewMotorRight;
            while(readPotentiometer()>viewStraightMax){
            motor[viewMotor] = 0;

            sharpLeft();
            motor[driveMotor] = highSpeed;
            clearTimer(T1);
            while(time1(T1)<reverseSwitchMSEC){
                if(beacon_found = beaconMonitor(ir_center)){
                    sharpRight();
                    sharpRight();
                    motor[driveMotor] = 0;
                    break;
                }
            }
            if(beacon_found)
                break;
            sharpLeftReverse();
            motor[driveMotor] = -highSpeed;
            while(time1(T1)<reverseSwitchMSEC){
                if(beacon_found = beaconMonitor(ir_center)){
                    sharpRightReverse();
                    sharpRightReverse();
                    motor[driveMotor] = 0;
                    break;
                }
            }
            if(beacon_found)
                break;
            }
        }else
            if(readPotentiometer()<viewStraightMin){ //if robot viewer is facing right
                motor[viewMotor] = viewMotorLeft;
                while(readPotentiometer()<viewStraightMin){
                motor[viewMotor] = 0;

                sharpRight();
                motor[driveMotor] = highSpeed;
                clearTimer(T1);
                while(time1(T1)<reverseSwitchMSEC){
                    if(beacon_found = beaconMonitor(ir_center)){
                        sharpLeft();
                        sharpLeft();
                        motor[driveMotor] = 0;
                        break;
                    }
                }
                sharpRightReverse();
                motor[driveMotor] = -highSpeed;
                while(time1(T1)<reverseSwitchMSEC){
                    if(beacon_found = beaconMonitor(ir_center)){
                        sharpLeftReverse();
                        sharpLeftReverse();
                        motor[driveMotor] = 0;
                        break;
                    }else
                        break;
                }//while
            }//if
        }//while


        //the following loop is to test if the robot is ready to attach the cable.
				    while(true){
            //check rangefinder and phototransistor

            if(rangeChecker()<7 && rangeChecker()>3)
                cableDistanceGood = true;
            else
                cableDistanceGood = false;
            if(beaconMonitor(ir_center)
                centerDetect = true;
            else
                centerDetect = false;
            if(cableDistanceGood && centerDetect)
                LEDOn = true;
            else
                LEDOn = false;
            if(ledOn)
                SensorValue[cableAttachLED] = 1;
         }
}
