/* DOT THESE THINGS

	SEEK FUNCTION ONLY HAPPENS ONCE
	WHILE REVERSEING FACE ON DIRECTION
	MAKE A FUNCTION FOR CHANGING THE THRESHOLD!!
*/

#pragma config(Sensor, in1,	potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in2,	ir_center,  	sensorReflection)
#pragma config(Sensor, in3,	ir_right,   	sensorReflection)
#pragma config(Sensor, in4,	ir_left,    	sensorReflection)
#pragma config(Sensor, dgtl2,  rangefinder,	sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  cableAttachLED, sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  beaconFoundLED, sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, button,     	sensorTouch)
#pragma config(Motor,  port1,       	viewMotor, 	tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,       	steerMotor,	tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,       	armMotor,  	tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,      	driveMotor,	tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard           	!!*//

//The power to give to the steer motor when driving it.
const int nSteerMotorPower = 20;
const int nLeft = -1;
const int nRight = +1;

//When the steer motor is activated at nSteerMotorPower the wheels will be start turning at a rate dependent on nSteerMotorPower.
//Thus nMaxSteerPosition is the maximum time (aka. position) the steer motor can have. It is called a position because
//the time multiplied by the direction (i.e. nLeft or nRight ) will give the position.
const int nMaxSteerPosition = 1000;
//A global to keep track of the accumulated steering position over many steering adjustments
int nCurrentSteerPosition;

const int iDriveMotorPower = 25;
const int iForward = 1;
const int iBackward = -1;

//The maximum distances of an object which is of interest to the robot
const int wallDangerDistance = 30;

const int iPotMax = 3650;	//highest value permitted for viewer potentiometer
const int iPotMin =	1650; //lowest value permitted for viewer potentiometer
const int iPotMidPoint = (iPotMax + iPotMin)/2;
const int iPotRange = iPotMax - iPotMin;

const int iViewMotorPower  = 22;
const int iViewMotorLeft = 1;
const int iViewMotorRight = -1;

bool bBeaconDetected;
bool bViewMotorOn;
bool bDriveMotorOn;
bool bRobotOn;

//Log the minimum distance measured during each sweep of the view motor. And do it with global variables
// so it is easy to monitor/debug.
int iMinDistanceLeft;
int iMinDistanceRight;
int iPotAtMinDistanceLeft;
int iPotAtMinDistanceRight;
bool bEndOfSweep;

void resetGlobalVariables(){ //For when button is pushed to turn robot off.
	bBeaconDetected = false;
	bViewMotorOn = false;
	bDriveMotorOn = false;
	nCurrentSteerPosition = 0;
	iMinDistanceLeft = 30000;
	iMinDistanceRight = 30000;
	iPotAtMinDistanceLeft = iPotMidPoint;
	iPotAtMinDistanceRight = iPotMidPoint;
	bEndOfSweep = false;
}


int readPotentiometer(){
	int iReturn = 0;
	while(iReturn ==0){
		iReturn = SensorValue(potentiometer);
	}
	return iReturn;
}

int readDistance(){
	int iReturn = 0;
	const int iAverageOf = 10;
	//Only return from this routine if the final return value is 2 or greater.
	while(iReturn <2){
		long lDistanceSum = 0;
		int iCounter = 0;
		int iDistance = 0;
		//The distance sensor returns erroneous low numbers sometimes, therefore take an average of <iAverageOf> readings
		while(iCounter <iAverageOf){
			iDistance = SensorValue(rangefinder);
			//Only use the reading if it is above 0
			//Even with this safegaurd in place, sometimes the return from this routine is erroneously low.
			if (iDistance > 0){
				iCounter = iCounter + 1;
				lDistanceSum = lDistanceSum + iDistance;
			}
			wait1Msec(10);
		}
		iReturn = lDistanceSum/iCounter;
	}
	return iReturn;
}


void initiateDistanceSensor(){
	//It seems that the first bunch of reading from the distance sensor are garbage.
	//So do a bunch prior to anything important
	int iCounter = 0;
	int blah;
	while(iCounter < 20){
		blah = SensorValue(rangefinder);
		iCounter = iCounter + 1;
		wait1Msec(50);
	}
}

void initiateDriveMotor(){
	motor[driveMotor] = iDriveMotorPower * iForward;
	bDriveMotorOn = true;
}

void turnSteering(int nSteerDirection, int nDriveDirection, int nChangeMSec){
	//Will adjust the steering in the indicated direction by the indicated amount (nChangeMSec). If the
	//steering position gets maxed out, then steering adjustment will stop.

	int nNewSteerPos;
	nNewSteerPos = nCurrentSteerPosition + (nSteerDirection * nChangeMSec);

	while((abs(nNewSteerPos) > nMaxSteerPosition) && (nChangeMSec > 0)){
		//Calculate the new steering position until we get something that doesn't max out the steering.
		nChangeMSec = nChangeMSec - 10;
		nNewSteerPos = nCurrentSteerPosition + (nSteerDirection * nChangeMSec);
	}

	//If we are allowed to change the steering (i.e. not maxed out) then do so, and keep track of the global nCurrentSteerPosition
	if(nChangeMSec > 0){
		motor[steerMotor] = nSteerDirection * nSteerMotorPower;
		wait1Msec(nChangeMSec);
		motor[steerMotor] = 0;
		nCurrentSteerPosition = nNewSteerPos;
	}
}

void initiateViewMotorDirection(){
	//Determines in which direction to start the view motor
	int iPotVal;
	iPotVal = readPotentiometer();
	if (iPotVal < iPotMidPoint){
		motor[viewMotor] = iViewMotorPower * iViewMotorLeft;
	}
	else{
		motor[viewMotor] = iViewMotorPower * iViewMotorRight;
	}
	bViewMotorOn = true;
}

void seekWalls(){
	int iPotVal;
	int iDistance = 0;
	
	iPotVal = readPotentiometer();
	if(iPotVal > iPotMax){ //if viewer facing left
		motor[viewMotor] = iViewMotorPower * iViewMotorRight;
	}

	if(iPotVal <= (iPotMin+100)){ //if viewer facing right
		motor[viewMotor] = iViewMotorPower * iViewMotorLeft;
	}

	iDistance = readDistance();

	//Log the minimum distance left and right
	if(iPotVal > iPotMax && iDistance < iMinDistanceLeft){
		iMinDistanceLeft = iDistance;
		iPotAtMinDistanceLeft = iPotVal;
	}
	if(iPotVal <= iPotMin && iDistance < iMinDistanceRight){
		iMinDistanceRight = iDistance;
		iPotAtMinDistanceRight = iPotVal;
	}
}
//these boolean values correspond to initial states. 
bool corner;
bool wall_left;
bool wall_right;
bool path_clear;

bool beacon_found;

typedef enum initState{
	CORNER,
	WALL_LEFT,
	WALL_RIGHT,
	PATH_CLEAR,
}initState

initState determineInitialState(int minDistLeft, int minDistRight){

	if(minDistLeft < wallDangerDistance && minDistRight < wallDangerDistance){
		corner = true;
		return CORNER;
	}else if(minDistLeft < wallDangerDistance){
		wall_left = true;
		return WALL_LEFT;
	}else if(minDistRight < wallDangerDistance){
		wall_right = true;
		return WALL_RIGHT;
	}else
		path_clear = true;
		return PATH_CLEAR;
	
}

void viewReset(){

	if(readPotentiometer() < iPotMidPoint){
		while(readPotentiometer() < iPotMidPoint)
			motor[viewMotor] = iViewMotorPower * iViewMotorLeft;
	}
	if(readPotentiometer() > iPotMidPoint){
		while(readPotentiometer() > iPotMidPoint)
			motor[viewMotor] = iViewMotorPower * iViewMotorRight;
	}

}

task main(){
	resetGlobalVariables();

	initiateDistanceSensor();

	while(true){
		if(SensorValue(button)){
			if (bRobotOn){
				bRobotOn = false;
				motor[viewMotor] =0;
				motor[driveMotor] = 0;
				motor[steerMotor] = 0;
			}else{
				bRobotOn = true;
				resetGlobalVariables();
			}
			wait1Msec(500);
		}

		if(bRobotOn){

			if (!bViewMotorOn) initiateViewMotorDirection();
			
			while(true){
				seekWalls();
				int leftCount;
				int rightCount;
				int pot = readPotentiometer();
				if(pot = iPotMax)
					leftCount++;
				if(pot = iPotMin)
					rightCount++;
				if(leftCount + rightCount >= 2 && pot > iPotMidPoint - 20 && pot < iPotMidPoint + 20)
					break;
			}

			//At the end of each sweep, evaluate the minimum distance that was measured during the sweep.
			motor[viewMotor] = 0;
			viewReset();
					
				//Reset the monitoring variables
				bEndOfSweep = false;
				iMinDistanceLeft = 30000;
				iMinDistanceRight = 30000;
				iPotAtMinDistanceLeft = iPotMidPoint;
				iPotAtMinDistanceRight = iPotMidPoint;
				break;

		} //bRobotOn
	}//while 1
		while(true){
			initState state1;
						
			state1 = determineInitialState(iMinDistanceLeft, iMinDistanceRight);
			
			switch(state1){
			
				case CORNER:
				
				motor[driveMotor] = iDriveMotorPower * iBackward;
				while(iMinDistanceLeft < wallDangerDistance || iMinDistanceRight < wallDangerDistance){
					seekWalls();
				}
				motor[driveMotor] = 0;
				//reset potentiometer
				int potVal = readPotentiometer();
				while(potVal < (iPotMidPoint - 20)){
					motor[viewMotor] = iViewMotorPower * iViewMotorLeft;
				}
				motor[viewMotor] = 0;
				while(potVal > (iPotMidPoint + 20)){
					motor[viewMotor] = iViewMotorPower * iViewMotorRight;
				}
				//begin reverse switch steering, beginning with reverse, while searching for beacon. 
				while(!beacon_found){
				
					//STEER AND TAKE IN VALUES FROM THE MF IR SENSOR
				
				}
			
			}
	}//while 2
}//main
